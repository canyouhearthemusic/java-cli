import java.io.*;
import java.nio.file.*;
import java.nio.file.attribute.*;
import java.text.*;
import java.util.*;

public class MyFile {

    private static String generatePath() {
        return "/tmp/" + new SimpleDateFormat("dd-MM-yyyy").format(new Date()) + ".backup";
    }

    // выводит список всех файлов и директорий для `path` - ls
    public static void listDirectory(String path) {
        try {
            File directory = new File(path);
            if (!directory.exists()) {
                System.out.println("Error: Directory does not exist.");
                return;
            }
            String[] files = directory.list();
            for (String file : files) {
                System.out.println(file);
            }
        } catch (Exception e) {
            System.out.println("Error: " + e.getMessage());
        }
    }

    // выводит список файлов с расширением `.py` в `path` - ls_py
    public static void listPythonFiles(String path) {
        try {
            File directory = new File(path);
            if (!directory.exists()) {
                System.out.println("Error: Directory does not exist.");
                return;
            }
            FilenameFilter filter = (dir, name) -> name.toLowerCase().endsWith(".py");
            String[] files = directory.list(filter);
            for (String file : files) {
                System.out.println(file);
            }
        } catch (Exception e) {
            System.out.println("Error: " + e.getMessage());
        }
    }

    // выводит `true`, если `path` это директория, в других случаях `false` - is_dir
    public static void isDirectory(String path) {
        try {
            File file = new File(path);
            System.out.println(file.isDirectory());
        } catch (Exception e) {
            System.out.println("Error: " + e.getMessage());
        }
    }

    // выводит `директория` или `файл` в зависимости от типа `path` - define
    public static void define(String path) {
        try {
            File file = new File(path);
            if (file.exists()) {
                if (file.isDirectory()) {
                    System.out.println("директория");
                } else {
                    System.out.println("файл");
                }
            } else {
                System.out.println("Error: File or directory does not exist.");
            }
        } catch (Exception e) {
            System.out.println("Error: " + e.getMessage());
        }
    }

    // выводит права для файла в формате `rwx` для текущего пользователя - readmod
    public static void printPermissions(String path) {
        try {
            Path filePath = Paths.get(path);
            Set<PosixFilePermission> permissions = Files.getPosixFilePermissions(filePath);
            System.out.print((permissions.contains(PosixFilePermission.OWNER_READ) ? "r" : "-"));
            System.out.print((permissions.contains(PosixFilePermission.OWNER_WRITE) ? "w" : "-"));
            System.out.println((permissions.contains(PosixFilePermission.OWNER_EXECUTE) ? "x" : "-"));
        } catch (Exception e) {
            System.out.println("Error: " + e.getMessage());
        }
    }

    // устанавливает права для файла `path` - setmod
    public static void setPermissions(String path, String permissions) {
        try {
            Path filePath = Paths.get(path);
            Set<PosixFilePermission> perms = new HashSet<>();
            if (permissions.contains("r")) perms.add(PosixFilePermission.OWNER_READ);
            if (permissions.contains("w")) perms.add(PosixFilePermission.OWNER_WRITE);
            if (permissions.contains("x")) perms.add(PosixFilePermission.OWNER_EXECUTE);
            Files.setPosixFilePermissions(filePath, perms);
            System.out.println("Permissions set successfully!");
        } catch (Exception e) {
            System.out.println("Error: " + e.getMessage());
        }
    }

    // выводит контент файла - cat
    public static void printContent(String path) {
        try {
            BufferedReader reader = new BufferedReader(new FileReader(path));
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
            reader.close();
        } catch (Exception e) {
            System.out.println("Error: " + e.getMessage());
        }
    }

    // добавляет строку `# Autogenerated line` в конец `path` - append
    public static void appendFooter(String path) {
        try {
            BufferedWriter writer = new BufferedWriter(new FileWriter(path, true));
            writer.write("# Autogenerated line\n");
            writer.close();
            System.out.println("Line appended successfully!");
        } catch (Exception e) {
            System.out.println("Error: " + e.getMessage());
        }
    }

    // создает копию `path` в директорию `/tmp/${date}.backup` где, date - это дата в формате `dd-mm-yyyy` - bc
    public static void createBackup(String path) {
        try {
            File source = new File(path);
            if (!source.exists()) {
                System.out.println("Error: File or directory does not exist.");
                return;
            }

            File destinationDir = new File(generatePath());

            if (source.isFile()) {
                Files.copy(source.toPath(), destinationDir.toPath());
                System.out.println("File backup created successfully!");
            } else if (source.isDirectory()) {
                copyDirectory(source, destinationDir);
                System.out.println("Directory backup created successfully!");
            } else {
                System.out.println("Error: Invalid path or not a file/directory.");
            }
        } catch (Exception e) {
            System.out.println("Error: " + e.getMessage());
        }
    }

    private static void copyDirectory(File source, File destination) throws IOException {
        if (!destination.exists()) {
            destination.mkdirs();
        }

        String[] files = source.list();
        for (String file : files) {
            File srcFile = new File(source, file);
            File destFile = new File(destination, file);
            if (srcFile.isDirectory()) {
                copyDirectory(srcFile, destFile);
            } else {
                Files.copy(srcFile.toPath(), destFile.toPath());
            }
        }
    }

    // выводит самое длинное слово в файле - greplong
    public static void printLongestWord(String path) {
        try {
            BufferedReader reader = new BufferedReader(new FileReader(path));
            String longestWord = "";
            String line;
            while ((line = reader.readLine()) != null) {
                String[] words = line.split("\\s+");
                for (String word : words) {
                    if (word.length() > longestWord.length()) {
                        longestWord = word;
                    }
                }
            }
            reader.close();
            System.out.println("Longest word: " + longestWord);
        } catch (Exception e) {
            System.out.println("Error: " + e.getMessage());
        }
    }

    // выводит список команд и их описание - help
    public static void help() {
        System.out.println("MyFS 1.0 команды:");
        System.out.println("ls <path>\t\tвыводит список всех файлов и директорий для `path`");
        System.out.println("ls_py <path>\t\tвыводит список файлов с расширением `.py` в `path`");
        System.out.println("is_dir <path>\t\tвыводит `true`, если `path` это директория, в других случаях `false`");
        System.out.println("define <path>\t\tвыводит `директория` или `файл` в зависимости от типа `path`");
        System.out.println("readmod <path>\t\tвыводит права для файла в формате `rwx` для текущего пользователя");
        System.out.println("setmod <path> <perm>\tустанавливает права для файла `path`");
        System.out.println("cat <path>\t\tвыводит контент файла");
        System.out.println("append <path>\t\tдобавляет строку `# Autogenerated line` в конец `path`");
        System.out.println("bc <path>\t\tсоздает копию `path` в директорию `/tmp/${date}.backup`");
        System.out.println("greplong <path>\t\tвыводит самое длинное слово в файле");
        System.out.println("help\t\t\tвыводит список команд и их описание");
        System.out.println("exit\t\t\tзавершает работу программы");
    }

    // завершает работу программы - exit
    public static void exit() {
        System.out.println("Goodbye");
        System.exit(0);
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        help();
        System.out.println("Введите команду:");

        while (true) {
            try {
                String input = reader.readLine().trim();
                String[] parts = input.split("\\s+");

                if (parts.length == 0 || parts[0].isEmpty()) {
                    continue;
                }

                String command = parts[0];

                switch (command) {
                    case "ls":
                        if (parts.length > 1) {
                            listDirectory(parts[1]);
                        } else {
                            System.out.println("Error: Insufficient arguments. Usage: ls <path>");
                        }
                        break;
                    case "ls_py":
                        if (parts.length > 1) {
                            listPythonFiles(parts[1]);
                        } else {
                            System.out.println("Error: Insufficient arguments. Usage: ls_py <path>");
                        }
                        break;
                    case "is_dir":
                        if (parts.length > 1) {
                            isDirectory(parts[1]);
                        } else {
                            System.out.println("Error: Insufficient arguments. Usage: is_dir <path>");
                        }
                        break;
                    case "define":
                        if (parts.length > 1) {
                            define(parts[1]);
                        } else {
                            System.out.println("Error: Insufficient arguments. Usage: define <path>");
                        }
                        break;
                    case "readmod":
                        if (parts.length > 1) {
                            printPermissions(parts[1]);
                        } else {
                            System.out.println("Error: Insufficient arguments. Usage: readmod <path>");
                        }
                        break;
                    case "setmod":
                        if (parts.length > 2) {
                            setPermissions(parts[1], parts[2]);
                        } else {
                            System.out.println("Error: Insufficient arguments. Usage: setmod <path> <permissions>");
                        }
                        break;
                    case "cat":
                        if (parts.length > 1) {
                            printContent(parts[1]);
                        } else {
                            System.out.println("Error: Insufficient arguments. Usage: cat <path>");
                        }
                        break;
                    case "append":
                        if (parts.length > 1) {
                            appendFooter(parts[1]);
                        } else {
                            System.out.println("Error: Insufficient arguments. Usage: append <path>");
                        }
                        break;
                    case "bc":
                        if (parts.length > 1) {
                            createBackup(parts[1]);
                        } else {
                            System.out.println("Error: Insufficient arguments. Usage: bc <path>");
                        }
                        break;
                    case "greplong":
                        if (parts.length > 1) {
                            printLongestWord(parts[1]);
                        } else {
                            System.out.println("Error: Insufficient arguments. Usage: greplong <path>");
                        }
                        break;
                    case "help":
                        help();
                        break;
                    case "exit":
                        exit();
                        break;
                    default:
                        System.out.println("Error: Unknown command. Type 'help' for list of commands.");
                        break;
                }
            } catch (IOException e) {
                System.out.println("Error reading input: " + e.getMessage());
            }
        }
    }
}